// Общая библиотека 1
const path = require("path");

/* Paths */
const COMMON_PATH_TO_SITE = path.join(path.resolve(), "project");
const COMMON_PATH_TO_PAGES = path.join(COMMON_PATH_TO_SITE, "src", "pages");
const COMMON_PATH_TO_PARTIALS = path.join(COMMON_PATH_TO_PAGES, "partials");

/* Pages */
const COMMON_PAGES = {
  REGISTRATION: path.join(COMMON_PATH_TO_PAGES, "registration.hbs"),
  REGISTRATION_CONFIRM: path.join(COMMON_PATH_TO_PAGES, "registration-confirm.hbs"),
  REGISTRATION_SUCCESS: path.join(COMMON_PATH_TO_PAGES, "registration-success.hbs"),
  REGISTRATION_DECLINE: path.join(COMMON_PATH_TO_PAGES, "registration-decline.hbs"),
  REGISTRATION_FAILURE: path.join(COMMON_PATH_TO_PAGES, "registration-failure.hbs"),
  LOGON: path.join(COMMON_PATH_TO_PAGES, "logon.hbs"),
  LOGON_FAILED: path.join(COMMON_PATH_TO_PAGES, "logon-failed.hbs"),
  FORGOT_PASSWORD: path.join(COMMON_PATH_TO_PAGES, "forgot-password.hbs"),
  LOGOUT: path.join(COMMON_PATH_TO_PAGES, "logout.hbs"),
  OUT_SERVICE: path.join(COMMON_PATH_TO_PAGES, "out-service.hbs"),
  SESSION_CLOSE: path.join(COMMON_PATH_TO_PAGES, "session-close.hbs"),
  APP: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  PRODUCTS: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  PROFILE: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  BASKET: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  ORDERS: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  GET_ORDER: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  GET_ORDER_SUCCESS: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  GET_ORDER_ERROR: path.join(COMMON_PATH_TO_PAGES, "app.hbs"),
  PAGE_404: path.join(COMMON_PATH_TO_PAGES, "page-404.hbs"),
};

/* HTTP Codes */
const HTTP_CODES = {
  OK: { code: 200, description: "Успешный запрос." },
  CREATED: { code: 201, description: "Ресурс успешно создан." },
  ACCEPTED: { code: 202, description: "Запрос принят, но ещё не обработан." },
  NO_CONTENT: { code: 204, description: "Успешный запрос, но тело ответа пусто." },
  BAD_REQUEST: { code: 400, description: "Некорректный запрос." },
  UNAUTHORIZED: { code: 401, description: "Необходима аутентификация." },
  FORBIDDEN: { code: 403, description: "Доступ к ресурсу запрещён." },
  NOT_FOUND: { code: 404, description: "Ресурс не найден." },
  METHOD_NOT_ALLOWED: { code: 405, description: "Метод не поддерживается." },
  CONFLICT: { code: 409, description: "Конфликт запроса с текущим состоянием сервера." },
  UNPROCESSABLE_ENTITY: { code: 422, description: "Ошибка валидации данных." },
  INTERNAL_SERVER_ERROR: { code: 500, description: "Внутренняя ошибка сервера." },
  NOT_IMPLEMENTED: { code: 501, description: "Метод не реализован на сервере." },
  BAD_GATEWAY: { code: 502, description: "Ошибка шлюза." },
  SERVICE_UNAVAILABLE: { code: 503, description: "Сервис временно недоступен." },
  GATEWAY_TIMEOUT: { code: 504, description: "Время ожидания ответа от шлюза истекло." },
};

/* User Roles */
const USER_ROLES = {
  CUSTOMER: 1,
  AUDITOR: 2,
  COORDINATOR: 3,
  OWNER: 4,
};

/* SQL Queries */
const SQL = {
  USER: {
    ASSIGN_ROLE: `INSERT INTO user_roles (user_id, role_id) VALUES(?, ?)`,
    CREATE: `INSERT INTO users (email, password, name) VALUES (?, ?, ?)`,
    FIND_BY_EMAIL: `SELECT * FROM users WHERE email = ?`,
    FIND_BY_ID: `SELECT * FROM users WHERE id = ?`,
    UPDATE_BY_ID: `UPDATE users SET name = ?, email = ? WHERE id = ?`,
    REVOKE_TOKEN : `INSERT INTO token_revoked (token) VALUES (?)`,
    IS_TOKEN_REVOKED : `SELECT * FROM token_revoked WHERE token = ?`,
  },
  ACCOUNT: {
    CREATE: `INSERT INTO accounts (user_id, balance) VALUES (?, 0)`,
    FIND_BY_ID: `SELECT * FROM accounts WHERE id = ?`,
    FIND_BY_USER_ID: `SELECT * FROM accounts WHERE user_id = ?`,
    UPDATE_BALANCE: `UPDATE accounts SET balance = ? WHERE id = ?`,
  },
  ORDER: {
    CREATE: `INSERT INTO orders (basket_id, user_id, amount, reference_id, status) VALUES (?, ?, ?, ?, 'pending')`,
    FIND_BY_ID: `SELECT * FROM orders WHERE id = ?`,
    UPDATE_STATUS: `UPDATE orders SET status = ? WHERE id = ?`,
  },
  BASKET: {
    CREATE: `INSERT INTO warehouse_basket (user_id) VALUES (?)`,
    FIND_BY_ID: `SELECT * FROM warehouse_basket WHERE id = ?`,
    FIND_BY_USER_ID: `SELECT * FROM warehouse_basket WHERE user_id = ?`,
    ADD_ITEM: `INSERT INTO warehouse_basket_item (basket_id, product_id, quantity) VALUES (?, ?, ?)`,
    REMOVE_ITEM: `DELETE FROM warehouse_basket_item WHERE basket_id = ? AND product_id = ?`,
    GET_ITEMS: `SELECT * FROM warehouse_basket_item WHERE basket_id = ?`,
  },
  WAREHOUSE: {
    RESERVE_ITEM: `UPDATE warehouse SET reserved_quantity = reserved_quantity + ? WHERE product_id = ?`,
    RELEASE_ITEM: `UPDATE warehouse SET reserved_quantity = reserved_quantity - ? WHERE product_id = ?`,
    FIND_PRODUCT_BY_ID: `SELECT * FROM warehouse WHERE product_id = ?`,
  },
  DELIVERY: {    
    FIND_COURIER_BY_TIME_SLOT: `SELECT * FROM delivery_couriers WHERE delivery_type_id = ? AND time_slot_id = ? `,
    FIND_COURIER_BY_ID :  `SELECT * FROM delivery_couriers WHERE courier_id = ? `,    
    GET_COURIER_ORDER_COUNT:  `SELECT count(id) FROM delivery WHERE delivery_date = ? and courier_id = ? `,
    FIND_COURIER : `
SELECT 
    dc.courier_id,
    dc.courier_name,
    dc.max_count,
    COUNT(d.id) AS current_orders
FROM 
    delivery_couriers dc
LEFT JOIN 
    delivery d
ON 
    dc.courier_id = d.courier_id
    AND d.delivery_date = ? -- Указать нужную дату
WHERE 
    dc.delivery_type_id = ? -- Тип доставки = 2
    AND dc.blocked_at IS NULL -- Только активные курьеры
    AND dc.deleted_at IS NULL -- Исключить удалённых курьеров
GROUP BY 
    dc.courier_id, dc.courier_name, dc.max_count
HAVING 
    COUNT(d.id) < dc.max_count -- Берём курьеров, у которых ещё есть свободные места
ORDER BY 
    current_orders ASC; -- Начинаем с курьеров с наименьшим числом заказов
 `,
 FIND_DELIVERY_ORDER : `SELECT * FROM delivery WHERE order_id = ? and courier_id is not null`,
 DELIVERY_ORDER_ADD :    `INSERT INTO delivery (order_id, delivery_date, courier_id) 
 VALUES (?, ?, ?) 
 ON DUPLICATE KEY UPDATE courier_id = ?`, 
DECLINE : `UPDATE delivery SET courier_id = null WHERE id = ? `,

    RESERVE_SLOT: `UPDATE delivery SET reserved = 1 WHERE courier_id = ? AND time_slot = ?`,
    RELEASE_SLOT: `UPDATE delivery SET reserved = 0 WHERE courier_id = ? AND time_slot = ?`,
  },
};

/* Order Statuses */
const OrderStatus = Object.freeze({
  NEW: "NEW",
  DELIVERY_TYPE_SPECIFIED: "DELIVERY_TYPE_SPECIFIED",
  PAYMENT_TYPE_SPECIFIED: "PAYMENT_TYPE_SPECIFIED",
  PAYMENT_COMPLETED: "PAYMENT_COMPLETED",
  ORDER_BEING_PREPARED: "ORDER_BEING_PREPARED",
  ORDER_SENT_TO_DELIVERY: "ORDER_SENT_TO_DELIVERY",
  SUCCESSFULLY_DELIVERED: "SUCCESSFULLY_DELIVERED",
  CANCELED: "CANCELED",
});

/* Экспорт */
module.exports = {
  COMMON_PATH_TO_SITE,
  COMMON_PATH_TO_PAGES,
  COMMON_PATH_TO_PARTIALS,
  COMMON_PAGES,
  HTTP_CODES,
  USER_ROLES,
  SQL,
  OrderStatus,
};
